[gd_scene load_steps=3 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

vec2 linearstep(vec2 edge0, vec2 edge1, vec2 x) {
	return clamp((x - (edge0)) / (edge1 - (edge0)), 0.0, 1.0);
}

void fragment() {
	vec4 color = vec4(1.0);
	vec3 uv = COLOR.rgb;
	vec2 uv_pixel = fwidth(uv.xy) * 10.0;
	
	vec2 corner_border = linearstep(vec2(0.0), uv_pixel, uv.xy);
	vec2 corner_border_fill = 1.0 - step(uv_pixel, uv.xy);
	vec2 hypotenuse_border = linearstep(vec2(1.0), vec2(1.0) - uv_pixel * 1.41, vec2(uv.x + uv.y));
	vec2 hypotenuse_border_fill = step(vec2(1.0) - uv_pixel * 1.41, vec2(uv.x + uv.y));
	
	//  uv.z controls whether each edge has antialiasing.
	//  0           N/A     0.0
	//  0   to 1/6  a       0.08
	//  1/6 to 2/6  ab      0.25
	//  2/6 to 3/6  abc     0.42
	//  3/6 to 4/6  b       0.58
	//  4/6 to 5/6  bc      0.75
	//  5/6 to 6/6  c       0.92
	
	uv.z = 0.92;

	float a = max(step(uv.z, 0.01), step(0.5, uv.z));
	float b = max(step(uv.z, 0.16), step(0.83, uv.z));
	float c = min(step(uv.z, 0.66), max(step(uv.z, 0.33), step(0.5, uv.z)));
	
	float alpha = max(a, corner_border.x) * max(b, corner_border.y) * max(c, hypotenuse_border.x * hypotenuse_border.y);
	alpha += min(a, corner_border_fill.x) + min(b, corner_border_fill.y) + min(c, hypotenuse_border_fill.x * hypotenuse_border_fill.y);
	color.a *= min(1.0, alpha);
	
	COLOR = color;
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )

[node name="Node2D" type="Node2D"]

[node name="Polygon2D" type="Polygon2D" parent="."]
material = SubResource( 2 )
position = Vector2( 102, 72 )
polygon = PoolVector2Array( 288, 371, 325, 239, 199, 326 )
vertex_colors = PoolColorArray( 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1 )
